# Plan: T-AE-02 → CSD Migration

**Date:** 2026-02-27  
**Scope:** arsresult · arsshells · arstlf · ars  
**Unblocked by:** Tasks 1–6 (all complete)

---

## Current state

T-AE-02 uses a "one analysis per cell" workaround:
- **33 analyses** (3 SOC × 3 arms + 8 PT × 3 arms), each pinned to one arm via
  `groupId` on `GRP_TRT` (`resultsByGroup: false`) and one SOC/PT via
  `dataSubsetId` carrying a compound expression `TRTEMFL=Y AND AEBODSYS/AEDECOD=<hardcoded>`.
- **11 data subsets** (3 SOC + 8 PT), each baking in both the TEAE flag and a
  hardcoded SOC or PT term.
- **Shell cells** reference individual analysis IDs (`AN_PT_PALP_TRT_A`, etc.).

This pattern cannot scale to new AE templates and is not CSD-aligned.

---

## Target CSD pattern

| | Current workaround | CSD target |
|---|---|---|
| Analyses | 33 (1 per cell) | 2 (`AN_AE_SOC`, `AN_AE_PT`) |
| Data subsets | 11 (`TRTEMFL=Y AND AEBODSYS=…`) | 1 (`DS_TEAE`: `TRTEMFL=Y`) |
| Groupings | GRP_TRT only (groupId pin) | GRP_TRT + GRP_SOC + GRP_PT (all `resultsByGroup: true`) |
| ARD rows | 33 analyses × 2 ops = 66 rows | 2 analyses × (3 TRT × 3 SOC + 3 TRT × 3 SOC × 8 PT) × 2 ops ≈ 162 rows |
| Shell cells | Reference analysis IDs directly | Reference analysis ID + result-group key |

---

## Step 1 — `arsresult/R/run.R`: `resultsByGroup: true` expansion

### What changes

Add a new execution path in `.compute_analysis()` for analyses where **any**
`orderedGrouping` has `resultsByGroup = TRUE` and the referenced grouping factor
has groups defined (non-empty after `hydrate()`).

### Algorithm

```
.compute_analysis():
  1. Apply analysis-set filter (unchanged)

  2. Classify ordered_groupings:
     - "pin" factors: resultsByGroup=FALSE with group_id set   → existing logic
     - "expand" factors: resultsByGroup=TRUE with groups defined → new logic

  3. Apply pin filters sequentially (existing code, unchanged).

  4. If no expand factors → existing single-result path (unchanged).

  5. Otherwise (expand factors present):
     a. Apply data_subset filter to get base_data.
     b. Generate Cartesian product of all expand_factor groups.
     c. For each combo in the Cartesian product:
        i.  For each factor in combo, apply that group's filter to base_data
            (condition or compound_expression) → combo_data.
        ii. Compute analysis_set_n for combo_data:
              - Cross-reference ADSL as before, but apply only the
                conditions from the current combo whose variable is
                present in ADSL. (This naturally gives N(arm) for TRT
                conditions; non-ADSL variables like AEBODSYS are skipped.)
        iii. Set attr(combo_data, "analysis_set_n") <- combo_set_n.
        iv. Call the method → result_pool (same as now).
        v.  Emit one ars_operation_result per declared operation, each
            carrying result_groups = list of ars_result_group for this combo.
     d. Collect and flatten all results across combos.
```

### Denominator correctness

ADSL cross-reference skips group conditions whose variable is absent from ADSL.
For a (TRT_A × SOC_Cardiac × PT_Palp) combo:
- TRT01A ∈ ADSL → ADSL filtered to TRT_A → N = 6 ✓
- AEBODSYS ∉ ADSL → skipped  
- AEDECOD ∉ ADSL → skipped  
Result: `analysis_set_n = 6` (arm size), not 4 (SOC/PT intersection). ✓

### New helper

Extract a private `.compute_set_n_for_combo()` helper that accepts:
`(data, ds_name, as_id, combo_groups, as_index, gf_index, adam_list)`.
This replaces the inline `analysis_set_n` block for the expand path.
The existing single-result path calls the same helper for consistency.

### Tests to add (`arsresult/tests/testthat/test-run.R`)

1. Single expand factor, 2 groups → 2 result rows with distinct result_groups.
2. Two expand factors (2 × 3) → 6 result rows.
3. Denominator for expand path equals arm N (cross-ref ADSL), not combo N.
4. Pin + expand combined: pin filter applied first, then expand over remaining groups.
5. Expand factor with `is_total = TRUE` group (no condition) → passes data through.

---

## Step 2 — `arsshells/inst/templates/tables/T-AE-02.json`: Rewrite

### New reporting event structure

**Analysis sets:** unchanged (`AS_SAFETY`: SAFFL=Y on ADAE).

**Data subsets** (1, down from 11):
```json
{
  "id": "DS_TEAE",
  "name": "Treatment-Emergent Adverse Events",
  "condition": { "variable": "TRTEMFL", "comparator": "EQ", "value": ["Y"] }
}
```

**Analysis groupings** (3, up from 1):
```
GRP_TRT  — dataDriven: false, groupingVariable: TRT01A
             groups: GRP_TRT_A (placeholder), GRP_TRT_B (placeholder), GRP_TRT_TOT (isTotal: true)
             (same as now — hydrate() fills arm conditions via group_map)

GRP_SOC  — dataDriven: true, groupingVariable: AEBODSYS, groups: []
             (hydrate() resolves from ADAE at run time)

GRP_PT   — dataDriven: true, groupingVariable: AEDECOD, groups: []
             (hydrate() resolves from ADAE at run time)
```

**Analyses** (2, down from 33):
```
AN_AE_SOC — dataSubsetId: DS_TEAE, methodId: METH_AE_FREQ
              orderedGroupings:
                {order:1, groupingId: GRP_TRT, resultsByGroup: true}
                {order:2, groupingId: GRP_SOC, resultsByGroup: true}

AN_AE_PT  — dataSubsetId: DS_TEAE, methodId: METH_AE_FREQ
              orderedGroupings:
                {order:1, groupingId: GRP_TRT, resultsByGroup: true}
                {order:2, groupingId: GRP_SOC, resultsByGroup: true}
                {order:3, groupingId: GRP_PT,  resultsByGroup: true}
```

**Shell sections and cells:**  
Each `ShellCell` adds a new optional `resultGroupFilters` field (list of
`{groupingId, groupId}` pairs) that `prep_ard_for_tfrmt()` uses to select the
correct ARD row. Example:

```json
{
  "analysisId": "AN_AE_PT",
  "operationId": "OP_N_PCT",
  "rowLabel": "Palpitations",
  "colLabel": "Treatment A (N=xx)",
  "resultGroupFilters": [
    { "groupingId": "GRP_TRT", "groupId": "GRP_TRT_A"  },
    { "groupingId": "GRP_SOC", "groupId": "GRP_SOC_CARDIAC" },
    { "groupingId": "GRP_PT",  "groupId": "GRP_PT_PALP" }
  ]
}
```

Group IDs for SOC/PT are assigned by `hydrate()` when resolving data-driven groups
(e.g., `GRP_SOC_CARDIAC` for "Cardiac disorders"). The template uses a naming
convention: `GRP_SOC_<SLUG>` and `GRP_PT_<SLUG>` where SLUG is derived from the
value.

**Note on `arsshells::ShellCell`:** Add `result_group_filters` property (list,
default `list()`). `hydrate()` does not need to do anything with it; it is passed
through as-is to `arstlf`.

---

## Step 3 — `arstlf/R/prep_ard.R`: result-group-aware geometry

### What changes

`ShellCell` may now carry `result_group_filters`. When present,
`.extract_shell_geometry()` emits those filters into the geometry tibble.
`prep_ard_for_tfrmt()` joins the ARD on `(analysis_id, operation_id)` AND on
the result_group filter (matching every `grouping_id → group_id` pair in the cell's
filter list).

### Geometry tibble changes

Add columns `rgf_key` (character, a serialised form of the result_group_filters
for joining; `NA` if none) to the geometry. In the ARD, derive a matching
`rgf_key` from the result_group columns.

### Backward compatibility

Cells without `result_group_filters` (all existing shells: T-DM-01, T-DS-01,
T-AE-01, T-LB-01, T-LB-02) continue to work as today — `rgf_key` is `NA` and
the join is purely on `(analysis_id, operation_id)`.

---

## Step 4 — `ars/tests/testthat/test-integration-T-AE-02.R`: Rewrite

The existing tests assert the old 33-analysis structure. The new tests assert:

1. Shell loads; RE has 2 analyses, 1 data subset, 3 grouping factors.
2. `run()` after hydration produces correct SOC and PT counts.
3. Denominator is arm N (ADSL), not combo intersection.
4. Monotonicity: SOC count ≥ any constituent PT count per arm.
5. `render()` returns `gt_tbl`.

The synthetic ADaM fixtures (`.adsl_ae02()`, `.adae_ae02()`) can be reused
mostly as-is — the data is the same; only which analysis IDs to assert changes.

---

## Execution order

1. **arsresult** — `run.R` expand path + tests  
2. **arsshells** — `ShellCell` S7 class + T-AE-02.json rewrite  
3. **arstlf** — `prep_ard.R` + `ShellCell` geometry  
4. **ars** — integration test rewrite  
5. Full test suite across all 5 packages  
6. Commit each package; update MASTER_PLAN

---

## Out of scope for this session

- Retiring the `groupId` arscore extension (other templates still use it)
- Phase B (section/row expansion)
- New templates (T-VS-01, T-AE-03…)
