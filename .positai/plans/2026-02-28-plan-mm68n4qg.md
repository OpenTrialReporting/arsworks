# Plan: §22 User Acceptance Testing (UAT)

**Date:** 2026-02-28  
**Priority:** High (new, above new template batch)

---

## Scope

Three interlocking concerns:

1. **Missing-category display inconsistency** — the literal string `"NA"` appears in
   some rendered cells instead of a blank, while other missing cells correctly render
   blank. This needs a systematic audit and consistent fix.

2. **Full-dataset performance** — `adlb_lb01` (7 PARAMCDs) and `adlb_lb02` (3 PARAMCDs)
   are currently used as a workaround for slow Mode 3 expansion on the full 47-PARAMCD
   ADLB. The goal is to make the full dataset fast enough to use, eliminating the
   need for pre-scoping as a performance workaround (clinical scoping remains valid
   semantically, but should not be *forced* by performance).

3. **End-to-end UAT review** — systematic walkthrough of shell → hydrate → run → render
   for all 6 shells to surface any remaining output correctness issues.

---

## §22.1 — Diagnose and fix blank vs "NA" inconsistency

### Root cause candidates

| Source | Mechanism | Symptom |
|--------|-----------|---------|
| `stdlib.R` `OP_MEAN`/`OP_SD` return `NaN` when n=0 | `mean(numeric(0))` → `NaN`; stored as `"NaN"` in raw_value | "NaN" or "NA" in cell |
| `prep_ard.R` row filter returns 0 rows → `return(NULL)` | Entire row absent from tfrmt input → blank cell | Correct blank ✓ |
| tfrmt `frmt("xx.x")` on NA numeric | tfrmt renders blank | Correct blank ✓ |
| `frmt("xx.x")` on `"NA"` string (not numeric NA) | `as.numeric("NA")` → `NA_real_` → blank ✓ or unpredictable | Needs verification |
| `raw_value = "NA"` string landing in a non-combined format | tfrmt may render literal "NA" if frmt doesn't catch it | **Likely culprit** |

### Steps

1. **Reproduce:** Run `data_table_examples.R` end-to-end and screenshot / capture all
   6 rendered `gt` tables. Flag any cell containing "NA", "NaN", or visually unexpected
   blank vs. value.

2. **Trace upstream:** For each flagged cell, filter the ARD to find the originating
   `raw_value`. Determine whether `"NA"` is entering as a character string vs. numeric
   `NA_real_`.

3. **Audit stdlib methods for edge cases:**
   - `OP_SD` when `n = 1` → `sd()` returns `NA_real_` ✓
   - `OP_MEAN` / `OP_MEDIAN` / `OP_MIN` / `OP_MAX` when `n = 0` → currently return
     `NA_real_` ✓
   - Verify `"NaN"` cannot reach `raw_value` (e.g. `mean(numeric(0), na.rm=TRUE)` =
     `NaN`).

4. **Audit `prep_ard.R` value path:** Confirm `as.numeric(raw_val)` → `NA` on `"NA"` /
   `"NaN"` strings propagates correctly to tfrmt, and that no format string produces
   literal `"NA"` text.

5. **Fix:** Add a guard in `prep_ard.R` or `run.R` to coerce `NaN` → `NA_real_` before
   storing into `raw_value`. Add a test in `arstlf/tests/` covering n=0 and n=1 cases.

---

## §22.2 — Full-dataset performance: remove forced scoping

### Current state

- `adlb_lb01` / `adlb_lb02` pre-filter ADLB to 7 / 3 PARAMCDs before `hydrate()`
  and `run()`, giving 28–117× speedups over the full 47-PARAMCD dataset.
- The `.observed_combos()` fast path (added in the observed-combos sprint) fires for
  T-AE-02 because TEAE pre-filtering removes orphan groups. The same fast path should
  theoretically fire for T-LB-01/02, but the 47-PARAMCD ADLB still takes 2–3.5 minutes.

### Investigation

Profile the T-LB-01 run on full ADLB to confirm where time is spent:

```r
Rprof(tmp <- tempfile())
run(sh_lb01_full, adam = list(ADLB = adlb, ADSL = adsl))
Rprof(NULL)
summaryRprof(tmp)
```

Hypotheses (in order of likelihood):

| Hypothesis | Expected root cause | Mitigation |
|------------|---------------------|------------|
| `.observed_combos()` not firing (Cartesian fallback) | Orphan PARAMCD groups or non-EQ conditions in template | Audit fast-path conditions; fix template or pre-filter to remove orphans |
| `.observed_combos()` fires but loop body is slow | 1500+ analyses × 6 ops × data-subset filtering per analysis | Vectorise the filter-and-count step; batch `data.table` or `dtplyr` |
| ADSL denominator re-filtered per analysis | 1500 redundant ADSL filter calls | Memoize: compute denom once per unique (analysis_set_id, group_combo) |

### Steps

1. **Profile** T-LB-01 on full `adlb` (47 PARAMCDs). Identify top-3 functions by
   self-time.

2. **Check fast-path eligibility** on full ADLB: does `.observed_combos()` return
   `NULL` (triggering Cartesian fallback)? If so, why?

3. **Option A — Memoize ADSL denominators.** The denominator for each
   (analysis_set_id, treatment_group) pair is always the same. Cache it in a named
   list keyed on `paste(analysis_set_id, grp_id)` before the analysis loop. Expected
   saving: O(n_analyses) → O(n_unique_combos) ADSL filter calls.

4. **Option B — Batch the method calls.** For Mode 3 expansion with a single PARAMCD
   grouping, all 47 PARAMCD × 3 arm combos for the same method could be computed in
   one vectorised pass rather than 141 individual calls.

5. **Target:** full 47-PARAMCD ADLB completes T-LB-01 in < 30 seconds (currently
   2–3.5 min). This removes the need for `adlb_lb01` as a performance workaround.

6. **Update `data_table_examples.R`:** Once the target is met, switch T-LB-01 and
   T-LB-02 to use full `adlb` (with clinical PARAMCDs still available as an optional
   scoping pattern, documented as a semantic choice not a performance workaround).

---

## §22.3 — End-to-end UAT review (all 6 shells)

For each shell, perform a structured review against the clinical specification:

### Review checklist (per shell)

| Check | Method |
|-------|--------|
| Row count matches expected | Compare rendered table row count to hand-counted expectation |
| Column headers show actual N (not "N=xx") | Visual + programmatic check of resolved headers |
| All expected categories present | Cross-reference shell sections vs. rendered rows |
| No "NA" / "NaN" text in cells | String scan of gt output |
| Zero-count cells show "0" not blank (where appropriate) | Check frequency rows for arms with no events |
| Percentages suppressed when N=0 (shows "0" not "0 (0.0%)") | Spot-check in AE tables |
| Totals / subtotals consistent | Spot arithmetic check |
| Section headers / indentation correct | Visual |

### Shell-specific notes

| Shell | Key UAT focus |
|-------|---------------|
| T-DM-01 | Continuous stats: SD undefined for n=1 subjects → should be blank |
| T-DS-01 | All disposition categories present even with 0 count |
| T-AE-01 | Value-map override (AEREL/AEACN) produces expected counts |
| T-AE-02 | All SOCs represented; zero-event SOC/PTs show "0" not blank |
| T-LB-01 | Baseline vs. CHG rows clearly distinguished; NaN guards active |
| T-LB-02 | Shift categories (Low/Normal/High) complete for all arms |

---

## §22.4 — MASTER_PLAN.md update

Add §22 UAT as a **High priority** item above the new template batch (Priority 1).
Update the priority table:

| Priority | Item |
|----------|------|
| **1** | **§22 UAT** — blank/NA fix, full-dataset performance, end-to-end review |
| **2** | New template batch (T-VS-01, T-AE-03–05, T-EF-01, T-EX-01) |
| **3** | `gt` backend in arstlf |
| **4** | `resultsByGroup: false` for comparison analyses |
| **5** | `referencedOperationRelationships` formal denominator |

---

## Execution order

1. §22.4 — Update MASTER_PLAN.md with the new priority and §22 section
2. §22.3 — Run all 6 shells; capture output; complete the UAT checklist
3. §22.1 — Diagnose blank vs NA; fix in `stdlib.R` / `prep_ard.R`; add tests
4. §22.2 — Profile T-LB-01 on full ADLB; implement fastest fix; update examples

---

## Deliverables

- [ ] MASTER_PLAN.md §22 section added, priority table updated
- [ ] UAT checklist completed for all 6 shells (results captured in MASTER_PLAN §22)
- [ ] `"NaN"` / `"NA"` guard in `stdlib.R` or `run.R` + regression test in `arstlf`
- [ ] T-LB-01 runs on full 47-PARAMCD ADLB in < 30 seconds
- [ ] `data_table_examples.R` updated to use full `adlb`
- [ ] All packages commit and push; test suites green
